/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * OpenAPI
 * 
This is the autogenerated OpenAPI documentation for your [Fuego](https://github.com/go-fuego/fuego) API.

Below is a Fuego Cheatsheet to help you get started. Don't hesitate to check the [Fuego documentation](https://go-fuego.github.io/fuego) for more details.

Happy coding! üî•

## Usage

### Route registration

```go
func main() {
	// Create a new server
	s := fuego.NewServer()

	// Register some routes
	fuego.Post(s, "/hello", myController)
	fuego.Get(s, "/myPath", otherController)
	fuego.Put(s, "/hello", thirdController)

	adminRoutes := fuego.Group(s, "/admin")
	fuego.Use(adminRoutes, myMiddleware) // This middleware (for authentication, etc...) will be available for routes starting by /admin/*, 
	fuego.Get(adminRoutes, "/hello", groupController) // This route will be available at /admin/hello

	// Start the server
	s.Start()
}
```

### Basic controller

```go
type MyBody struct {
	Name string `json:"name" validate:"required,max=30"`
}

type MyResponse struct {
	Answer string `json:"answer"`
}

func hello(ctx fuego.ContextWithBody[MyBody]) (*MyResponse, error) {
	body, err := ctx.Body()
	if err != nil {
		return nil, err
	}

	return &MyResponse{Answer: "Hello " + body.Name}, nil
}
```

### Add openAPI information to the route

```go
import (
	"github.com/go-fuego/fuego"
	"github.com/go-fuego/fuego/option"
	"github.com/go-fuego/fuego/param"
)

func main() {
	s := fuego.NewServer()

	// Custom OpenAPI options
	fuego.Post(s, "/", myController
		option.Description("This route does something..."),
		option.Summary("This is my summary"),
		option.Tags("MyTag"), // A tag is set by default according to the return type (can be deactivated)
		option.Deprecated(), // Marks the route as deprecated in the OpenAPI spec

		option.Query("name", "Declares a query parameter with default value", param.Default("Carmack")),
		option.Header("Authorization", "Bearer token", param.Required()),
		optionPagination,
		optionCustomBehavior,
	)

	s.Run()
}

var optionPagination = option.Group(
	option.QueryInt("page", "Page number", param.Default(1), param.Example("1st page", 1), param.Example("42nd page", 42)),
	option.QueryInt("perPage", "Number of items per page"),
)

var optionCustomBehavior = func(r *fuego.BaseRoute) {
	r.XXX = "YYY"
}
```

Then, in the controller

```go
type MyResponse struct {
	Answer string `json:"answer"`
}

func getAllPets(ctx fuego.ContextNoBody) (*MyResponse, error) {
	name := ctx.QueryParam("name")
	perPage, _ := ctx.QueryParamIntErr("per_page")

	return &MyResponse{Answer: "Hello " + name}, nil
}
```

 * OpenAPI spec version: 0.0.1
 */
import useSwr from 'swr'
import type {
  Key,
  SWRConfiguration
} from 'swr'
import useSWRMutation from 'swr/mutation'
import type {
  SWRMutationConfiguration
} from 'swr/mutation'
import type {
  HTTPError,
  TaskToCreate,
  UserToCreate
} from './model'
import {
  faker
} from '@faker-js/faker'
import {
  HttpResponse,
  delay,
  http
} from 'msw'
import type {
  Task,
  User
} from './model'
import { customInstance } from '../../lib/custom-instance';
import type { ErrorType, BodyType } from '../../lib/custom-instance';



  
  type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*TaskHandler).SearchTasks`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary search tasks
 */
export const gETTasks = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<Task[]>(
    {url: `/tasks`, method: 'GET'
    },
    options);
  }



export const getGETTasksKey = () => [`/tasks`] as const;

export type GETTasksQueryResult = NonNullable<Awaited<ReturnType<typeof gETTasks>>>
export type GETTasksQueryError = ErrorType<HTTPError | void>

/**
 * @summary search tasks
 */
export const useGETTasks = <TError = ErrorType<HTTPError | void>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof gETTasks>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGETTasksKey() : null);
  const swrFn = () => gETTasks(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*TaskHandler).CreateTask`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary create task
 */
export const pOSTTasks = (
    taskToCreate: BodyType<TaskToCreate>,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<Task>(
    {url: `/tasks`, method: 'POST',
      headers: {'Content-Type': '*/*', },
      data: taskToCreate
    },
    options);
  }



export const getPOSTTasksMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: TaskToCreate }): Promise<Task> => {
    return pOSTTasks(arg, options);
  }
}
export const getPOSTTasksMutationKey = () => [`/tasks`] as const;

export type POSTTasksMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTTasks>>>
export type POSTTasksMutationError = ErrorType<HTTPError | void>

/**
 * @summary create task
 */
export const usePOSTTasks = <TError = ErrorType<HTTPError | void>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof pOSTTasks>>, TError, Key, TaskToCreate, Awaited<ReturnType<typeof pOSTTasks>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPOSTTasksMutationKey();
  const swrFn = getPOSTTasksMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*TaskHandler).GetTask`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary get task
 */
export const gETTasksId = (
    id: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<Task>(
    {url: `/tasks/${id}`, method: 'GET'
    },
    options);
  }



export const getGETTasksIdKey = (id: string,) => [`/tasks/${id}`] as const;

export type GETTasksIdQueryResult = NonNullable<Awaited<ReturnType<typeof gETTasksId>>>
export type GETTasksIdQueryError = ErrorType<HTTPError | void>

/**
 * @summary get task
 */
export const useGETTasksId = <TError = ErrorType<HTTPError | void>>(
  id: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof gETTasksId>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGETTasksIdKey(id) : null);
  const swrFn = () => gETTasksId(id, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*TaskHandler).UpdateTask`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary update task
 */
export const pUTTasksId = (
    id: string,
    task: BodyType<Task>,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<Task>(
    {url: `/tasks/${id}`, method: 'PUT',
      headers: {'Content-Type': '*/*', },
      data: task
    },
    options);
  }



export const getPUTTasksIdMutationFetcher = (id: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: Task }): Promise<Task> => {
    return pUTTasksId(id, arg, options);
  }
}
export const getPUTTasksIdMutationKey = (id: string,) => [`/tasks/${id}`] as const;

export type PUTTasksIdMutationResult = NonNullable<Awaited<ReturnType<typeof pUTTasksId>>>
export type PUTTasksIdMutationError = ErrorType<HTTPError | void>

/**
 * @summary update task
 */
export const usePUTTasksId = <TError = ErrorType<HTTPError | void>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof pUTTasksId>>, TError, Key, Task, Awaited<ReturnType<typeof pUTTasksId>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPUTTasksIdMutationKey(id);
  const swrFn = getPUTTasksIdMutationFetcher(id, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*UserHandler).SearchUsers`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary search users
 */
export const gETUsers = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User[]>(
    {url: `/users`, method: 'GET'
    },
    options);
  }



export const getGETUsersKey = () => [`/users`] as const;

export type GETUsersQueryResult = NonNullable<Awaited<ReturnType<typeof gETUsers>>>
export type GETUsersQueryError = ErrorType<HTTPError | void>

/**
 * @summary search users
 */
export const useGETUsers = <TError = ErrorType<HTTPError | void>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof gETUsers>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGETUsersKey() : null);
  const swrFn = () => gETUsers(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*UserHandler).CreateUser`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary create user
 */
export const pOSTUsers = (
    userToCreate: BodyType<UserToCreate>,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>(
    {url: `/users`, method: 'POST',
      headers: {'Content-Type': '*/*', },
      data: userToCreate
    },
    options);
  }



export const getPOSTUsersMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: UserToCreate }): Promise<User> => {
    return pOSTUsers(arg, options);
  }
}
export const getPOSTUsersMutationKey = () => [`/users`] as const;

export type POSTUsersMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTUsers>>>
export type POSTUsersMutationError = ErrorType<HTTPError | void>

/**
 * @summary create user
 */
export const usePOSTUsers = <TError = ErrorType<HTTPError | void>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof pOSTUsers>>, TError, Key, UserToCreate, Awaited<ReturnType<typeof pOSTUsers>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPOSTUsersMutationKey();
  const swrFn = getPOSTUsersMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*UserHandler).GetUser`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary get user
 */
export const gETUsersId = (
    id: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>(
    {url: `/users/${id}`, method: 'GET'
    },
    options);
  }



export const getGETUsersIdKey = (id: string,) => [`/users/${id}`] as const;

export type GETUsersIdQueryResult = NonNullable<Awaited<ReturnType<typeof gETUsersId>>>
export type GETUsersIdQueryError = ErrorType<HTTPError | void>

/**
 * @summary get user
 */
export const useGETUsersId = <TError = ErrorType<HTTPError | void>>(
  id: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof gETUsersId>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGETUsersIdKey(id) : null);
  const swrFn = () => gETUsersId(id, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * #### Controller: 

`github.com/lighttiger2505/wakabata/internal/app.(*UserHandler).UpdateUser`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---


 * @summary update user
 */
export const pUTUsersId = (
    id: string,
    user: BodyType<User>,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>(
    {url: `/users/${id}`, method: 'PUT',
      headers: {'Content-Type': '*/*', },
      data: user
    },
    options);
  }



export const getPUTUsersIdMutationFetcher = (id: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: User }): Promise<User> => {
    return pUTUsersId(id, arg, options);
  }
}
export const getPUTUsersIdMutationKey = (id: string,) => [`/users/${id}`] as const;

export type PUTUsersIdMutationResult = NonNullable<Awaited<ReturnType<typeof pUTUsersId>>>
export type PUTUsersIdMutationError = ErrorType<HTTPError | void>

/**
 * @summary update user
 */
export const usePUTUsersId = <TError = ErrorType<HTTPError | void>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof pUTUsersId>>, TError, Key, User, Awaited<ReturnType<typeof pUTUsersId>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPUTUsersIdMutationKey(id);
  const swrFn = getPUTUsersIdMutationFetcher(id, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}



export const getGETTasksResponseMock = (): Task[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), due_date: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), priority: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), project_id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), status: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})))

export const getPOSTTasksResponseMock = (overrideResponse: Partial< Task > = {}): Task => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), due_date: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), priority: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), project_id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), status: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getGETTasksIdResponseMock = (overrideResponse: Partial< Task > = {}): Task => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), due_date: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), priority: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), project_id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), status: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getPUTTasksIdResponseMock = (overrideResponse: Partial< Task > = {}): Task => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), due_date: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), priority: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), project_id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), status: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getGETUsersResponseMock = (): User[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), password_hash: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), username: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))

export const getPOSTUsersResponseMock = (overrideResponse: Partial< User > = {}): User => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), password_hash: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), username: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), ...overrideResponse})

export const getGETUsersIdResponseMock = (overrideResponse: Partial< User > = {}): User => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), password_hash: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), username: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), ...overrideResponse})

export const getPUTUsersIdResponseMock = (overrideResponse: Partial< User > = {}): User => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), id: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), password_hash: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), username: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), ...overrideResponse})


export const getGETTasksMockHandler = (overrideResponse?: Task[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Task[]> | Task[])) => {
  return http.get('*/tasks', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGETTasksResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPOSTTasksMockHandler = (overrideResponse?: Task | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Task> | Task)) => {
  return http.post('*/tasks', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getPOSTTasksResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGETTasksIdMockHandler = (overrideResponse?: Task | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Task> | Task)) => {
  return http.get('*/tasks/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGETTasksIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPUTTasksIdMockHandler = (overrideResponse?: Task | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Task> | Task)) => {
  return http.put('*/tasks/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getPUTTasksIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGETUsersMockHandler = (overrideResponse?: User[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User[]> | User[])) => {
  return http.get('*/users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGETUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPOSTUsersMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<User> | User)) => {
  return http.post('*/users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getPOSTUsersResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGETUsersIdMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User> | User)) => {
  return http.get('*/users/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGETUsersIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPUTUsersIdMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<User> | User)) => {
  return http.put('*/users/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getPUTUsersIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getOpenAPIMock = () => [
  getGETTasksMockHandler(),
  getPOSTTasksMockHandler(),
  getGETTasksIdMockHandler(),
  getPUTTasksIdMockHandler(),
  getGETUsersMockHandler(),
  getPOSTUsersMockHandler(),
  getGETUsersIdMockHandler(),
  getPUTUsersIdMockHandler()
]
